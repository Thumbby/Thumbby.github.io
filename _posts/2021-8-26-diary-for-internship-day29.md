---
layout: post
title:  "实习日记29(EasyExcelDemo)"
date:   2021-08-26
categories: jekyll update
---

Day29

- 这周剩下两天要把之前写的demo整合进公司的框架，博客的话可能不会有多少东西，遇到了什么问题再更新吧。

- 昨晚面试问到了IO复用，但是我听成了IO film，算了这里还是写一下，顺便早上去看了牙齿晚上面试真的恶心。

  - I/O模型

    - 阻塞式 I/O

      应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。 应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都 被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。

      ![img](https://img2018.cnblogs.com/blog/1102427/201903/1102427-20190306142652603-1084445531.png)

    - 非阻塞式I/O

      应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的 执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。 由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。

      ![img](https://img2018.cnblogs.com/blog/1102427/201903/1102427-20190306142827583-1565779258.png)

  - I/O复用

    - 原因：如果一个I/O流进来，我们就开启一个进程处理这个I/O流。那么假设现在有一百万个I/O流进来，那我们就需要开启一百万个进程一一对应处理这些I/O流（——这就是传统意义下的多进程并发处理）。思考一下，一百万个进程，你的CPU占有率会多高，这个实现方式及其的不合理。所以人们提出了I/O多路复用这个模型，一个线程，通过记录I/O流的状态来同时管理多个I/O，可以提高服务器的吞吐能力

    - 使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程 会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。 它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。 如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。 如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

      ![img](https://img2018.cnblogs.com/blog/1102427/201903/1102427-20190306143002103-1545280521.png)

- 今天整合完了，但是还有不创建对象读没有测试过，明天试一下没问题的话就可以上传写wiki了，不过这里框架多一层handler还不允许不同微服务之间调用有点难受的，可能以前自己写代码的规范不大行。

- 发现个东西记录一下：

  - 使用@Autowired注解警告Field injection is not recommended

    来源：https://blog.csdn.net/zhangjingao/article/details/81094529
    
    这里需要先讲一下依赖注入的三种方式：
    
    - 变量注入
    
      ```java
      @Autowired
      UserDao userDao;
      ```
    
    - 构造器注入
    
      ```java
      final
      UserDao userDao;
      
      @Autowired
      public UserServiceImpl(UserDao userDao) {
          this.userDao = userDao;
      }
      ```
    
    - set方法注入
    
      ```java
      private UserDao userDao;
      
      @Autowired
      public void setUserDao (UserDao userDao) {
         this.userDao = userDao;
      }
      ```
    
      相比较而言：
    
      优点：变量方式注入非常简洁，没有任何多余代码，非常有效的提高了java的简洁性。即使再多几个依赖一样能解决掉这个问题。
    
      缺点：不能有效的指明依赖。相信很多人都遇见过一个bug，依赖注入的对象为null，在启动依赖容器时遇到这个问题都是配置的依赖注入少了一个注解什么的，然而这种方式就过于依赖注入容器了，当没有启动整个依赖容器时，这个类就不能运转，在反射时无法提供这个类需要的依赖。
      在使用set方式时，这是一种选择注入，可有可无，即使没有注入这个依赖，那么也不会影响整个类的运行。
      在使用构造器方式时已经显式注明必须强制注入。通过强制指明依赖注入来保证这个类的运行。
    
      另一个方面：
      依赖注入的核心思想之一就是被容器管理的类不应该依赖被容器管理的依赖，换成白话来说就是如果这个类使用了依赖注入的类，那么这个类摆脱了这几个依赖必须也能正常运行。然而使用变量注入的方式是不能保证这点的。
      既然使用了依赖注入方式，那么就表明这个类不再对这些依赖负责，这些都由容器管理，那么如何清楚的知道这个类需要哪些依赖呢？它就要使用set方法方式注入或者构造器注入。
    
      总结下：
      变量方式注入应该尽量避免，使用set方式注入或者构造器注入，这两种方式的选择就要看这个类是强制依赖的话就用构造器方式，选择依赖的话就用set方法注入。


​    