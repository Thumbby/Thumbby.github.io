---
layout: post
title:  "实习日记77(JVM编译)"
date:   2021-11-17
categories: jekyll update
---

## Day77

- 继续学习Java虚拟机规范，基于https://docs.oracle.com/javase/specs/jvms/se8/html/

- ### JVM编译

  - #### 编译finally

    这节假设编译器在50.0或者更低的版本下生成的class文件，这样jsr指令可能被用到。见4.10.2.5

    try-finally语句的编译和try-catch的编译时相似的。在执行完try代码块之前（无论有没有抛出异常），finally语句块的内容都将被执行。看一个简单的例子：

    ```java
    void tryFinally() {
        try {
            tryItOut();
        } finally {
            wrapItUp();
        }
    }
    ```

    编译后：

    ```
    Method void tryFinally()
    0   aload_0             // Beginning of try block
    1   invokevirtual #6    // Method Example.tryItOut()V
    4   jsr 14              // Call finally block
    7   return              // End of try block
    8   astore_1            // Beginning of handler for any throw
    9   jsr 14              // Call finally block
    12  aload_1             // Push thrown value
    13  athrow              // ...and rethrow value to the invoker
    14  astore_2            // Beginning of finally block
    15  aload_0             // Push this
    16  invokevirtual #5    // Method Example.wrapItUp()V
    19  ret 2               // Return from finally block
    Exception table:
    From    To      Target      Type
    0       4       8           any
    ```

    控制传递到try语句之外有四种方法：执行完代码块，返回，执行break或continue语句，或者引发异常。 如果tryItOut返回而没有引发异常，则使用jsr指令将控制转移到finally块。 索引4处的jsr 14指令对索引14处的finally块的代码进行“子程序调用”（finally块被编译为嵌入式子例程）。 当finally块完成时，ret 2指令将控制返回到索引4处的jsr指令之后的指令。

    更详细地说，子例程调用的工作原理如下：jsr指令在跳转之前将下一条指令的地址（在索引7处返回）推送到操作数堆栈上。 作为跳转目标的astore_2指令将操作数堆栈上的地址存储到本地变量2中。运行finally块的代码（在本例中为aload_0和invokevirtual指令）。 假设该代码的执行正常完成，则ret指令从局部变量2中检索地址并在该地址处继续执行。 执行返回指令，tryFinally正常返回。

    更详细地说，子例程调用的工作原理如下：jsr指令在跳转之前将下一条指令的地址（在索引7处返回）推送到操作数堆栈上。 作为跳转目标的astore_2指令将操作数堆栈上的地址存储到本地变量2中。运行finally块的代码（在本例中为aload_0和invokevirtual指令）。 假设该代码的执行正常完成，则ret指令从局部变量2中检索地址并在该地址处继续执行。 执行返回指令，tryFinally正常返回。

    编译包含catch和finally语句的try语句会更复杂一点：

    ```java
    void tryCatchFinally() {
        try {
            tryItOut();
        } catch (TestExc e) {
            handleExc(e);
        } finally {
            wrapItUp();
        }
    }
    ```

    编译为：

    ```
    Method void tryCatchFinally()
    0   aload_0             // Beginning of try block
    1   invokevirtual #4    // Method Example.tryItOut()V
    4   goto 16             // Jump to finally block
    7   astore_3            // Beginning of handler for TestExc;
                            // Store thrown value in local var 3
    8   aload_0             // Push this
    9   aload_3             // Push thrown value
    10  invokevirtual #6    // Invoke handler method:
                            // Example.handleExc(LTestExc;)V
    13  goto 16             // This goto is unnecessary, but was
                            // generated by javac in JDK 1.0.2
    16  jsr 26              // Call finally block
    19  return              // Return after handling TestExc
    20  astore_1            // Beginning of handler for exceptions
                            // other than TestExc, or exceptions
                            // thrown while handling TestExc
    21  jsr 26              // Call finally block
    24  aload_1             // Push thrown value...
    25  athrow              // ...and rethrow value to the invoker
    26  astore_2            // Beginning of finally block
    27  aload_0             // Push this
    28  invokevirtual #5    // Method Example.wrapItUp()V
    31  ret 2               // Return from finally block
    Exception table:
    From    To      Target      Type
    0       4       7           Class TestExc
    0       16      20          any
    ```

    如果try语句正常完成，则索引4处的goto指令跳转到索引16处finally块的子例程调用。执行索引26处的finally块，控制返回索引19处的返回指令，并且tryCatchFinally正常返回。

    如果tryItOut抛出TestExc的实例，则选择异常表中的第一个（最上层的）适用的异常处理程序来处理异常。 从索引7开始，该异常处理程序的代码将抛出的值传递给handleExc，并且在其返回时对索引26处的finally块进行相同的子例程调用，如同正常情况一样。 如果handleExc没有抛出异常，则tryCatchFinally会正常返回。

    如果tryItOut抛出的值不是TestExc的实例，或者如果handleExc本身抛出异常，则该条件由异常表中的第二个条目处理，该条件处理索引0和16之间抛出的任何值。该异常处理程序将控制转移到 索引20，其中抛出的值首先存储在局部变量1中。索引26处的finally块的代码被称为子例程。 如果返回，则从局部变量1检索抛出的值，并使用athrow指令重新抛出。 如果在执行finally子句期间抛出新值，则finally子句将中止，并且tryCatchFinally异常返回，将新值抛给其调用者。

  - #### 同步

    java虚拟机是用过monitor的进入和退出来实现同步的，不管是显示（使用monitorenter和monitorexit指令）或者隐式（通过方法调用和return指令）。

    java编程语言编写的代码，可能最通用的同步形式就是同步方法。同步方法不是通过monitorenter和monitorexit简单实现。而是简单通过运行时常量池中的ACC_SYNCHRONIZED标识来区分，通过方法调用指令来检查这个标识。

    monitorenter和monitorexit指令用同步代码块的编译。例如：

    ```java
    void onlyMe(Foo f) {
        synchronized(f) {
            doSomething();
        }
    }
    ```

    编译为：

    ```
    Method void onlyMe(Foo)
    0   aload_1             // Push f
    1   dup                 // Duplicate it on the stack
    2   astore_2            // Store duplicate in local variable 2
    3   monitorenter        // Enter the monitor associated with f
    4   aload_0             // Holding the monitor, pass this and...
    5   invokevirtual #5    // ...call Example.doSomething()V
    8   aload_2             // Push local variable 2 (f)
    9   monitorexit         // Exit the monitor associated with f
    10  goto 18             // Complete the method normally
    13  astore_3            // In case of any throw, end up here
    14  aload_2             // Push local variable 2 (f)
    15  monitorexit         // Be sure to exit the monitor!
    16  aload_3             // Push thrown value...
    17  athrow              // ...and rethrow value to the invoker
    18  return              // Return in the normal case
    Exception table:
    From    To      Target      Type
    4       10      13          any
    13      16      13          any
    ```

    编译器确保在任何方法调用完成时，将对自方法调用以来执行的每个monitorenter指令执行monitorexit指令。 无论方法调用是正常完成（第2.6.4节）还是异常完成（第2.6.5节），都是如此。 为了在方法异常调用完成时保证monitorenter和monitorexit指令的配对，编译器会生成异常处理程序（第2.10节），它将匹配任何异常并且其相关代码执行必要的monitorexit指令。

  - #### 注解

    4.7.16-4.7.22节中给出了注解在class文件中表示。这些章节中明确描述了在class文件格式中，如何描述修饰类型，字段和方法的注解。这里只描述关于注解的一些额外规则。

    当编译器遇到必须在运行时可用的带注释的包声明时，它会生成一个具有以下属性的class文件：

    - class文件表示的是一个接口，那么ACC_INTERFACE和ACC_ABSTRACT标识在ClassFile的结构中被设置
    - 如果class文件的版本号低于50.0，然后ACC_SYNTHETIC标识不会设置；如果版本号大于等于50.0，那么ACC_SYNTHETIC标识被设置。
    - 接口具有包访问权限。
    - 接口的名称是package-name.package-info的内部形式。
    - 这个接口没有父类
    - 接口的唯一成员是Java语言规范Java SE 8 Edition（JLS§9.2）所暗示的成员。
    - 声明上的注释在ClassFile结构的属性表中存储为RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations属性。

- 复习第2章和第3章，并且第1章为历史之类的，不做了解。